from numpy import abs, any, arange, array, diag, exp, linspace, log, logical_or, matmul, mean, nonzero, ones, pi, sin, sqrt, transpose, trapz, zeros
from numpy.linalg import inv
from numpy.random import uniform
import matplotlib.pyplot as plt

# Boolean values to control plotting
run_task_1 = False
run_task_2 = False
run_task_3 = True
run_user_simulation = True
show_phase_space_plots = True
# This doesn't apply to the user defined simulation since the phase space plot is the only returned result
# for that simulation

# Declaring constants

dt = pi/20 # Time step
epsilon0 = 1 # Our chosen normalization
particle_mass = 1 # For simplicity
particle_charge = 1 # For simplicity
simulation_time = 8*pi
vx_FWHM = 2 # Full width at half maximum of our Maxwellian distribution
x_domain_endpoints = [-pi, pi] # Expected form: [low_endpoint, high_endpoint]
vx_domain_endpoints = [-5, 5] # Expected form: [low_endpoint, high_endpoint]

u = 0 # This is an assumption

x_domain_length = x_domain_endpoints[1] - x_domain_endpoints[0]
vx_domain_length = vx_domain_endpoints[1] - vx_domain_endpoints[0]

# Getting input from user

if run_user_simulation:
    while True:
        user_num_particles = input('Enter the number of particles for the simulation: ')
        try:
            user_num_particles = int(user_num_particles)
            break
        except:
            print('Please enter an integer number of particles')

    while True:
        user_num_grid_points = input('Enter the number of grid points to be used for the simulation: ')
        try:
            user_num_grid_points = int(user_num_grid_points)
            break
        except:
            print('Please enter an integer number of grid points')

    while True:
        user_weighting_order = input('Enter a 0 or 1 to use 0th or 1st order particle weighting: ')
        try:
            user_weighting_order = int(user_weighting_order)
            assert(user_weighting_order == 0 or user_weighting_order == 1)
            break
        except:
            print('Please enter a 0 or 1\n')
            continue

# Declaring functions

def charge_weighting(grid, particle_state, weighting_order):
    '''
    Takes the spatial grid, particle state, and weighting order as input, then returns the charge weighted grid 
    generated by the particles.
    The returned charge_weighted_grid will be a column vector
    '''
    num_grid_points = len(grid)
    charge_weighted_grid = zeros((num_grid_points, 1))
    grid_spacing = grid[1]-grid[0]
    num_particles = len(particle_state[0])
    total_charge = num_particles*particle_charge
    if weighting_order == 0:
        for i in range(num_particles):
            nearest_grid_index = (abs(grid-particle_state[0][i])).argmin()
            charge_weighted_grid[nearest_grid_index] += particle_charge
            # if nearest_grid_index == 0: 
            #     # Keeping the endpoints consistent. This doesn't double count charges since the grid points at either end are the same point in space
            #     # since we are using periodic boundary conditions
            #     charge_weighted_grid[-1] += particle_charge
            # elif nearest_grid_index == num_grid_points:
            #     charge_weighted_grid[0] += particle_charge
    elif weighting_order == 1:
        for i in range(num_particles):
            grid_distance_array = abs(grid-particle_state[0][i])
            nearest_grid_distance = grid_distance_array.min()
            nearest_grid_index = grid_distance_array.argmin()
            if nearest_grid_distance == 0: # We here handle the case that the particle is exactly on a grid point
                charge_weighted_grid[nearest_grid_index] += particle_charge
                continue
            second_nearest_grid_distance = grid_spacing - nearest_grid_distance
            if particle_state[0][i] > grid[nearest_grid_index]:
                second_nearest_grid_index = nearest_grid_index + 1
            else:
                second_nearest_grid_index = nearest_grid_index - 1
            charge_weighted_grid[nearest_grid_index] += particle_charge*second_nearest_grid_distance/grid_spacing
            charge_weighted_grid[second_nearest_grid_index] += particle_charge*nearest_grid_distance/grid_spacing
            # if nearest_grid_index == 0: 
            #     # Keeping the endpoints consistent. This doesn't double count charges since the grid points at either end are the same point in space
            #     # since we are using periodic boundary conditions
            #     charge_weighted_grid[-1] += particle_charge*second_nearest_grid_distance/grid_spacing
            # elif nearest_grid_index == num_grid_points-1:
            #     charge_weighted_grid[0] += particle_charge*second_nearest_grid_distance/grid_spacing
            # if second_nearest_grid_index == 0:
            #     charge_weighted_grid[-1] += particle_charge*nearest_grid_distance/grid_spacing
            # elif second_nearest_grid_index == num_grid_points-1:
            #     charge_weighted_grid[0] += particle_charge*nearest_grid_distance/grid_spacing
    charge_weighted_grid -= total_charge/num_grid_points # This is the assumption of a uniform background
    return charge_weighted_grid

def compute_electric_field_energy(electric_field, grid_spacing):
    '''
    Computes the energy stored in the provided electric field
    ''' 
    return epsilon0*trapz(electric_field**2/2, axis=0, dx=grid_spacing)

def compute_kinetic_energy(particle_state):
    '''
    Computes the kinetic energy of the particles in the given state
    '''
    return particle_mass*sum(particle_state[1]**2)

def field_solve(charge_weighted_grid, grid_spacing):
    '''
    Takes the charge weighted grid as input then returns the electric field generated
    '''

    num_grid_points = len(charge_weighted_grid)

    # Solving Poisson's equation for the potential

    A = diag(-2*ones(num_grid_points)) + diag(ones(num_grid_points-1), 1) + diag(ones(num_grid_points-1), -1)

    # We set the the potential in the middle of the grid to 0 to set our gauge
    middle_index = num_grid_points//2 
    middle_row = zeros(num_grid_points)
    middle_row[middle_index] = 1
    A[middle_index] = middle_row

    # Apply periodic boundary conditions
    A[0][-1] = 1
    A[-1][0] = 1

    A = (1/grid_spacing**2)*A
    potential = matmul(inv(A), -charge_weighted_grid/epsilon0)

    # Computing the derivative of the potential to get the electric field

    B = diag(-ones(num_grid_points-1),-1) + diag(ones(num_grid_points-1), 1)

    # Apply periodic boundary conditions
    B[0][-1] = -1
    B[-1][0] = 1

    B = -1/(2*grid_spacing)*B

    electric_field = matmul(B, potential)
    return electric_field

def find_oscillation_frequency(vector, total_time):
    mean_value = mean(vector)
    zero_crossings = 0
    last_element = 0
    for element in vector:
        if element == vector[0]:
            last_element = element
            continue
        elif element >= mean_value and last_element < mean_value or element < mean_value and last_element >= mean_value:
            zero_crossings += 1
            last_element = element
    frequency = zero_crossings/total_time
    return frequency

def force_weighting(electric_field, grid, particle_state, weighting_order):
    '''
    Takes the electric field, spatial grid, particle state, and weighting order as input, then returns 
    the forces generated by the electric field on the particles.
    '''
    num_particles = len(particle_state[0])
    forces = zeros((num_particles, 1))
    grid_spacing = grid[1]-grid[0]
    if weighting_order == 0:
        for i in range(num_particles):
            nearest_grid_index = (abs(grid-particle_state[0][i])).argmin()
            forces[i] = particle_charge*electric_field[nearest_grid_index]
    elif weighting_order == 1:
        for i in range(num_particles):
            grid_distance_array = abs(grid-particle_state[0][i])
            nearest_grid_distance = grid_distance_array.min()
            nearest_grid_index = grid_distance_array.argmin()
            if nearest_grid_distance == 0: # We here handle the case that the particle is exactly on a grid point
                forces[i] = particle_charge*electric_field[nearest_grid_index]
                continue
            second_nearest_grid_distance = grid_spacing - nearest_grid_distance
            if particle_state[0][i] > grid[nearest_grid_index]:
                second_nearest_grid_index = nearest_grid_index + 1
            else:
                second_nearest_grid_index = nearest_grid_index - 1
            forces[i] = particle_charge*(electric_field[nearest_grid_index]*(second_nearest_grid_distance/grid_spacing) 
                                        + electric_field[second_nearest_grid_index]*(nearest_grid_distance/grid_spacing)) 
    return forces

def inverse_maxwellian(kT_over_m, f, u):
    """
    kT_over_m is expected to be a float representing Boltzmann's constant times the temperature of the particles in the Maxwellian velocity
    distribution over the mass of the particles in the Maxwellian velocity distribution
    f is expected to be a float or vector of floats representing the output of a Maxwellian velocity distribution

    We ignore the negative square root for our purposes (the slice sampling below)
    """
    return u+sqrt(-2*kT_over_m*log(f*(1/(2*pi*kT_over_m))**(-3/2)))

def maxwellian(kT_over_m, vx, u):
    """
    kT_over_m is expected to be a float representing Boltzmann's constant times the temperature of the particles in the Maxwellian velocity
    distribution over the mass of the particles in the Maxwellian velocity distribution
    vx is expected to be a float or vector of floats representing the velocity

    We use n=1 since the integral of the probability density over all space should be 1
    """
    return (1/(2*pi*kT_over_m))**(3/2)*exp(-(1/(2*kT_over_m))*(vx-u)**2)

def maxwellian_slice_sample(kT_over_m, num_samples):
    '''
    Takes the ratio kt/m and number of samples to be generated as input and returns the specified number of samples
    from the Maxwellian distribution specified by the ratio kt/m.
    '''
    vx = 0
    samples = zeros((num_samples, 1))
    for i in range(num_samples):
        f = uniform(low=0, high=maxwellian(kT_over_m, vx, u))
        vx = uniform(low=-inverse_maxwellian(kT_over_m, f, u), high=inverse_maxwellian(kT_over_m, f, u), size=1) 
        # This uses that the Maxwellian distribution function is even and monotonically decreases going away from vx=0
        samples[i] = vx
    return samples  

def particle_push(dt, forces, particle_state):
    '''
    Takes the time step, forces on particles, and particle state as input, and returns the particle state
    advanced in time by one time step.
    The velocities in particle_state are expected to be one half step behind the positions.
    '''
    # Advancing the velocities
    new_velocities = particle_state[1]+(forces/particle_mass)*dt
    new_positions = particle_state[0]+new_velocities*dt
    # The below handles our periodic boundary conditions
    if any(logical_or(new_positions<x_domain_endpoints[0], new_positions>x_domain_endpoints[1])):
        too_low_indices = nonzero(new_positions<x_domain_endpoints[0])[0]
        too_high_indices = nonzero(new_positions>x_domain_endpoints[1])[0]
        for i in range(len(too_low_indices)):
            new_positions[too_low_indices[i]] += x_domain_length
        for i in range(len(too_high_indices)):
            new_positions[too_high_indices[i]] -= x_domain_length
    new_particle_state = [new_positions, new_velocities]
    return new_particle_state

def plot_energy_histories(electric_field_energy_history, kinetic_energy_history, t_vec, plot_name='Energy Histories'):
    '''
    Plots the electric field energy history, kinetic energy history, and the history of the sum of their energies.
    We ignore that the kinetic_energy_history is reported for times that are one half of a time step behind the electric field energy.
    '''
    plt.figure()
    plt.semilogy(t_vec, electric_field_energy_history)
    plt.semilogy(t_vec, kinetic_energy_history)
    plt.semilogy(t_vec, array(electric_field_energy_history)+array(kinetic_energy_history))
    plt.title(plot_name)
    plt.xlabel('Time')
    plt.ylabel('Energy')
    plt.legend(['Electric Field Energy History', 'Kinetic Field Energy History', 'Total Energy History'])
    plt.show()

def run_simulation(grid, initial_particle_state, t_vec, weighting_order, show_phase_space_plot=False, simulation_name='1D Plasma Simulation'):
    '''
    Runs a simulation with the given parameters
    '''
    dt = t_vec[1]-t_vec[0]
    electric_field_energy_history = []
    grid_spacing = grid[1]-grid[0]
    kinetic_energy_history = []
    for t in t_vec:
        if t == 0: # Not integrating this step aligns time t with the particle state after the time step
            particle_state = initial_particle_state
            charge_weighted_grid = charge_weighting(grid, particle_state, weighting_order)
            electric_field = field_solve(charge_weighted_grid, grid_spacing)
            electric_field_energy_history.append(compute_electric_field_energy(electric_field, grid_spacing))
            kinetic_energy_history.append(compute_kinetic_energy(particle_state))
        else:
            [particle_state, electric_field] = time_step(dt, grid, grid_spacing, particle_state, weighting_order)
            electric_field_energy_history.append(compute_electric_field_energy(electric_field, grid_spacing))
            kinetic_energy_history.append(compute_kinetic_energy(particle_state))
        if show_phase_space_plot:
            plt.scatter(*particle_state)
            plt.xlim(x_domain_endpoints[0], x_domain_endpoints[1])
            plt.ylim(vx_domain_endpoints[0], vx_domain_endpoints[1])
            plt.title(simulation_name)
            plt.xlabel('Position')
            plt.ylabel('Velocity')
            plt.show(block=False)
            plt.pause(0.05)
            if t == t_vec[-1]:
                plt.close()
            else:
                plt.clf()
    return [particle_state, electric_field_energy_history, kinetic_energy_history]

def time_step(dt, grid, grid_spacing, particle_state, weighting_order):
    '''
    Takes a particle state as input and returns the system state advanced in time by dt.
    The velocities in particle_state are assumed to be one half step behind the positions in particle_state.
    The electric field is passed along with the new particle state so it can be used in the energy history diagnostic.
    '''
    charge_weighted_grid = charge_weighting(grid, particle_state, weighting_order)
    electric_field = field_solve(charge_weighted_grid, grid_spacing)
    forces = force_weighting(electric_field, grid, particle_state, weighting_order)
    new_particle_state = particle_push(dt, forces, particle_state)
    # fig = plt.figure('test')
    # plt.plot(charge_weighted_grid)
    # plt.show(block=False)
    # plt.pause(0.05)
    # plt.cla()
    return [new_particle_state, electric_field]

# User Simulation

if run_user_simulation:

    grid = linspace(x_domain_endpoints[0], x_domain_endpoints[1], num=user_num_grid_points) # Note that this includes both endpoints
    grid_spacing = grid[1]-grid[0]

    # Finding the Maxwellian velocity distribution with the desired FWHM
    kT_over_m = -vx_FWHM/(8*log(1/2)) # See project 1.1 report for derivation

    # Generating initial conditions for user simulation

    particle_x = uniform(low=x_domain_endpoints[0], high=x_domain_endpoints[1], size=(user_num_particles, 1))
    particle_vx = maxwellian_slice_sample(kT_over_m, user_num_particles)

    # We now correct any points in particle_vx that aren't in our domain
    fmax = maxwellian(kT_over_m, u, u)
    while True: # Loop to make sure resampled values aren't out of our domain themselves
        if any(logical_or(particle_vx<vx_domain_endpoints[0], particle_vx>vx_domain_endpoints[1])):
            bad_value_indices = nonzero(logical_or(particle_vx<vx_domain_endpoints[0], particle_vx>vx_domain_endpoints[1]))
            for index in bad_value_indices:
                particle_vx[index] = maxwellian_slice_sample(kT_over_m, 1) # Resample bad indices
        else:
            break

    initial_particle_state = [particle_x, particle_vx]
    t_vec = arange(0, simulation_time+dt, dt) # The extra dt accounts for arange not including the stop value
    [final_particle_state, electric_field_energy_history, kinetic_energy_history] = run_simulation( 
                                                                                                grid, 
                                                                                                initial_particle_state, 
                                                                                                t_vec, 
                                                                                                user_weighting_order, 
                                                                                                show_phase_space_plot=True, 
                                                                                                simulation_name='User Simulation'
                                                                                                )
            
# Task 1: Two particles with zero initial velocity

if run_task_1:

    initial_particle_state = [array([[-pi/4], [pi/4]]), array([[0], [0]])]
    num_grid_points = 33
    t_vec = arange(0, simulation_time+dt, dt) # The extra dt accounts for arange not including the stop value
    weighting_orders = [0, 1]

    grid = linspace(x_domain_endpoints[0], x_domain_endpoints[1], num=num_grid_points) # Note that this includes both endpoints

    [final_particle_state, electric_field_energy_history, kinetic_energy_history] = run_simulation( 
                                                                                                grid, 
                                                                                                initial_particle_state, 
                                                                                                t_vec, 
                                                                                                weighting_orders[0], 
                                                                                                show_phase_space_plot=show_phase_space_plots, 
                                                                                                simulation_name='Two Particles with no Initial Velocity, 0th Order Weighting'
                                                                                                )

    [final_particle_state, electric_field_energy_history, kinetic_energy_history] = run_simulation( 
                                                                                                grid, 
                                                                                                initial_particle_state, 
                                                                                                t_vec, 
                                                                                                weighting_orders[1], 
                                                                                                show_phase_space_plot=show_phase_space_plots, 
                                                                                                simulation_name='Two Particles with no Initial Velocity, 1st Order Weighting'
                                                                                                )
    plot_energy_histories(electric_field_energy_history, kinetic_energy_history, t_vec, plot_name='Task 1 First Order Weighting Energy Histories')
    oscillation_frequency = find_oscillation_frequency(kinetic_energy_history, simulation_time)
    print(f'Task 1 Oscillation Frequency: {oscillation_frequency}')

# Task 2: Two particles with nonzero initial velocity

if run_task_2:

    num_grid_points = 33
    weighting_orders = [0, 1]
    vprime = 1
    initial_particle_state = [array([[-pi/2], [pi/2]]), array([[vprime], [vprime]])]

    grid = linspace(x_domain_endpoints[0], x_domain_endpoints[1], num=num_grid_points) # Note that this includes both endpoints
    t_vec = arange(0, simulation_time+dt, dt) # The extra dt accounts for arange not including the stop value

    [final_particle_state, electric_field_energy_history, kinetic_energy_history] = run_simulation( 
                                                                                                grid, 
                                                                                                initial_particle_state, 
                                                                                                t_vec, 
                                                                                                weighting_orders[0], 
                                                                                                show_phase_space_plot=show_phase_space_plots, 
                                                                                                simulation_name='Two Particles with Small Initial Velocity, 0th Order Weighting'
                                                                                                )
    [final_particle_state, electric_field_energy_history, kinetic_energy_history] = run_simulation( 
                                                                                                grid, 
                                                                                                initial_particle_state, 
                                                                                                t_vec, 
                                                                                                weighting_orders[1], 
                                                                                                show_phase_space_plot=show_phase_space_plots, 
                                                                                                simulation_name='Two Particles with Small Initial Velocity, 1st Order Weighting'
                                                                                                )
    plot_energy_histories(electric_field_energy_history, kinetic_energy_history, t_vec, plot_name='Task 2 1st Order Weighting Energy Histories')
    oscillation_frequency = find_oscillation_frequency(kinetic_energy_history, simulation_time)
    print(f'Task 2 Oscillation Frequency: {oscillation_frequency}')

# Task 3: 64 particles

if run_task_3:
    num_grid_points = 33
    num_particles = 64
    weighting_order = 1

    grid = linspace(x_domain_endpoints[0], x_domain_endpoints[1], num=num_grid_points) # Note that this includes both endpoints
    
    particle_positions = transpose(linspace(x_domain_endpoints[0], x_domain_endpoints[1], num_particles)[None])
    particle_velocities = 10**-3*sin((particle_positions+x_domain_endpoints[0])*2*pi/x_domain_length)
    initial_particle_state = [particle_positions, particle_velocities]

    t_vec = arange(0, simulation_time+dt, dt) # The extra dt accounts for arange not including the stop value

    dts = [pi/50, pi/40, pi/30, pi/20, pi/10]

    for dt in dts:
        [final_particle_state, electric_field_energy_history, kinetic_energy_history] = run_simulation( 
                                                                                                grid, 
                                                                                                initial_particle_state, 
                                                                                                t_vec, 
                                                                                                weighting_order, 
                                                                                                show_phase_space_plot=show_phase_space_plots, 
                                                                                                simulation_name='64 Particles with Sinusoidal Velocity Perturbation, 1st Order Weighting'
                                                                                                )
        if dt == pi/50:
            formatted_dt = '$\\frac{\pi}{50}$'
        elif dt == pi/40:
            formatted_dt = '$\\frac{\pi}{40}$'
        elif dt == pi/30:
            formatted_dt = '$\\frac{\pi}{30}$'
        elif dt == pi/20:
            formatted_dt = '$\\frac{\pi}{20}$'
        elif dt == pi/10:
            formatted_dt = '$\\frac{\pi}{10}$'
        else:
            formatted_dt = dt
        plot_energy_histories(electric_field_energy_history, kinetic_energy_history, t_vec, plot_name=f'Task 3 Energy Histories dt={formatted_dt}')
        if dt == pi/50:
            formatted_dt = 'pi/50'
        elif dt == pi/40:
            formatted_dt = 'pi/40'
        elif dt == pi/30:
            formatted_dt = 'pi/30'
        elif dt == pi/20:
            formatted_dt = 'pi/20'
        elif dt == pi/10:
            formatted_dt = 'pi/10'
        else:
            formatted_dt = dt
        oscillation_frequency = find_oscillation_frequency(kinetic_energy_history, simulation_time)
        print(f'Task 3 dt={formatted_dt} Oscillation Frequency: {oscillation_frequency}')