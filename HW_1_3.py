from numpy import abs, any, arange, array, concatenate, diag, expand_dims, linspace, logical_or, matmul, nonzero, ones, pi, polyfit, sin, sqrt, trapz, zeros
from numpy.linalg import inv
import matplotlib.pyplot as plt

# Boolean values to control what is run and shown
run_task_2 = False
run_task_3 = False
run_task_4 = False
run_task_5 = True
run_task_6 = False
show_phase_space_plots = True

# Declaring constants

beam_displacement_amplitude = 0.001
beam_velocity = 1
dt = pi/20 # Time step
epsilon0 = 1 # Chosen normalization
num_grid_points = 512
num_beam_particles = 512
particle_mass = 1 # For simplicity
particle_charge = 1 # Choice
simulation_time = 8*pi
vx_domain_endpoints = [-5, 5] # Expected form: [low_endpoint, high_endpoint]
weighting_order = 1
x_domain_endpoints = [-pi, pi] # Expected form: [low_endpoint, high_endpoint]

x_domain_length = x_domain_endpoints[1] - x_domain_endpoints[0]
vx_domain_length = vx_domain_endpoints[1] - vx_domain_endpoints[0]

# Declaring functions

def charge_weighting(grid, particle_state, weighting_order):
    '''
    Takes the spatial grid, particle state, and weighting order as input, then returns the charge weighted grid 
    generated by the particles.
    The returned charge_weighted_grid will be a column vector
    '''
    num_grid_points = len(grid)
    charge_weighted_grid = zeros((num_grid_points, 1))
    grid_spacing = grid[1]-grid[0]
    num_particles = len(particle_state[0])
    total_charge = num_particles*particle_charge
    if weighting_order == 0:
        for i in range(num_particles):
            nearest_grid_index = (abs(grid-particle_state[0][i])).argmin()
            charge_weighted_grid[nearest_grid_index] += particle_charge
    elif weighting_order == 1:
        for i in range(num_particles):
            grid_distance_array = abs(grid-particle_state[0][i])
            nearest_grid_distance = grid_distance_array.min()
            nearest_grid_index = grid_distance_array.argmin()
            if nearest_grid_distance == 0: # We here handle the case that the particle is exactly on a grid point
                charge_weighted_grid[nearest_grid_index] += particle_charge
                continue
            second_nearest_grid_distance = grid_spacing - nearest_grid_distance
            if nearest_grid_index == num_grid_points-1:
                second_nearest_grid_index = num_grid_points-2
            elif nearest_grid_index == 0:
                second_nearest_grid_index = 1
            elif particle_state[0][i] > grid[nearest_grid_index]:
                second_nearest_grid_index = nearest_grid_index + 1
            else:
                second_nearest_grid_index = nearest_grid_index - 1
            charge_weighted_grid[nearest_grid_index] += particle_charge*second_nearest_grid_distance/grid_spacing
            charge_weighted_grid[second_nearest_grid_index] += particle_charge*nearest_grid_distance/grid_spacing
    charge_weighted_grid -= total_charge/num_grid_points # This is the assumption of a uniform background
    return charge_weighted_grid

def compute_electric_field_energy(electric_field, grid_spacing):
    '''
    Computes the energy stored in the provided electric field
    The provided electric field is expected to be in the units of the simulation
    ''' 
    return epsilon0*trapz(1/2*electric_field**2, axis=0, dx=grid_spacing)

def compute_two_stream_instability_growth_rate(plasma_frequency):
    '''
    Computes the two stream instability maximum growrth rate for a plasma with the provided plasma frequency

    We currently use the approximation that omega_i,max=0.002*plasma_frequency
    '''
    return 0.002*plasma_frequency   

def compute_kinetic_energy(particle_state):
    '''
    Computes the kinetic energy of the particles in the given state
    '''
    return particle_mass*sum(particle_state[1]**2)

def compute_plasma_frequency(grid, num_particles):
    '''
    Computes the plasma frequency for the system given by the grid and number of particles
    '''
    grid_length = grid[-1]-grid[0]
    number_density = num_particles/grid_length
    return sqrt(number_density*particle_charge**2/(particle_mass*epsilon0))

def field_solve(charge_weighted_grid, grid_spacing):
    '''
    Takes the charge weighted grid as input then returns the electric field generated
    '''

    num_grid_points = len(charge_weighted_grid)

    # Solving Poisson's equation for the potential

    A = diag(-2*ones(num_grid_points)) + diag(ones(num_grid_points-1), 1) + diag(ones(num_grid_points-1), -1)

    # We set the the potential in the middle of the grid to 0 to set our gauge
    middle_index = num_grid_points//2 
    middle_row = zeros(num_grid_points)
    middle_row[middle_index] = 1
    A[middle_index] = middle_row

    # Apply periodic boundary conditions
    A[0][-1] = 1
    A[-1][0] = 1

    A = (1/grid_spacing**2)*A
    potential = matmul(inv(A), -charge_weighted_grid/epsilon0)

    # Computing the derivative of the potential to get the electric field

    B = diag(-ones(num_grid_points-1),-1) + diag(ones(num_grid_points-1), 1)

    # Apply periodic boundary conditions
    B[0][-1] = -1
    B[-1][0] = 1

    B = -1/(2*grid_spacing)*B

    electric_field = matmul(B, potential)
    return electric_field

def force_weighting(electric_field, grid, particle_state, weighting_order):
    '''
    Takes the electric field, spatial grid, particle state, and weighting order as input, then returns 
    the forces generated by the electric field on the particles.
    '''
    num_particles = len(particle_state[0])
    forces = zeros((num_particles, 1))
    grid_spacing = grid[1]-grid[0]
    num_grid_points = len(grid)
    if weighting_order == 0:
        for i in range(num_particles):
            nearest_grid_index = (abs(grid-particle_state[0][i])).argmin()
            forces[i] = particle_charge*electric_field[nearest_grid_index]
    elif weighting_order == 1:
        for i in range(num_particles):
            grid_distance_array = abs(grid-particle_state[0][i])
            nearest_grid_distance = grid_distance_array.min()
            nearest_grid_index = grid_distance_array.argmin()
            if nearest_grid_distance == 0: # We here handle the case that the particle is exactly on a grid point
                forces[i] = particle_charge*electric_field[nearest_grid_index]
                continue
            second_nearest_grid_distance = grid_spacing - nearest_grid_distance
            if nearest_grid_index == num_grid_points-1:
                second_nearest_grid_index = num_grid_points-2
            elif nearest_grid_index == 0:
                second_nearest_grid_index = 1
            elif particle_state[0][i] > grid[nearest_grid_index]:
                second_nearest_grid_index = nearest_grid_index + 1
            else:
                second_nearest_grid_index = nearest_grid_index - 1
            forces[i] = particle_charge*(electric_field[nearest_grid_index]*(second_nearest_grid_distance/grid_spacing) 
                                        + electric_field[second_nearest_grid_index]*(nearest_grid_distance/grid_spacing)) 
    return forces

def generate_beam_particles(num_beam_particles, x_domain_endpoints):
    '''
    Generates the initial particle state of two counter streaming beams with a small perturbation (but otherwise uniform position)
    '''
    x_domain_length = x_domain_endpoints[1]-x_domain_endpoints[0]
    beam = linspace(x_domain_endpoints[0], x_domain_endpoints[1], num_beam_particles)
    positive_beam_x = beam+beam_displacement_amplitude*sin(beam*2*pi/x_domain_length)
    negative_beam_x = -beam+beam_displacement_amplitude*sin(beam*2*pi/x_domain_length*+pi)
    combined_beams_x = concatenate((positive_beam_x, negative_beam_x))
    particle_x = expand_dims(combined_beams_x, 1)
    positive_beam_vx = beam_velocity*ones((num_beam_particles, 1))
    negative_beam_vx = -beam_velocity*ones((num_beam_particles, 1))
    particle_vx = concatenate((positive_beam_vx, negative_beam_vx))
    initial_particle_state = [particle_x, particle_vx]
    return initial_particle_state

def generate_grid(num_grid_points, x_domain_endpoints):
    '''
    Generates a grid from the provided domain endpoints and number of grid points
    Note that the result includes both endpoints of the domain
    '''
    return linspace(x_domain_endpoints[0], x_domain_endpoints[1], num_grid_points)

def generate_time_vector(dt, simulation_time):
    '''
    Generates the time vector for a simulation with the given total time and time step
    '''
    return arange(0, simulation_time+dt, dt) # The extra dt accounts for arange not including the stop value

def measure_two_stream_instability_growth_rate(electric_field_energy_history, t_vec):
    '''
    Measures the two stream instability growth rate from the provided electric field energy history

    Does so by fitting a line to the electric field energy value and returning the slope of that line
    '''
    coefficients = polyfit(t_vec, electric_field_energy_history, 1)
    return coefficients[1][0]

def particle_push(dt, forces, grid, particle_state):
    '''
    Takes the time step, forces on particles, and particle state as input, and returns the particle state
    advanced in time by one time step.
    The velocities in particle_state are expected to be one half step behind the positions.
    '''
    left_boundary = grid[0]
    right_boundary = grid[-1]
    domain_length = right_boundary-left_boundary
    # Advancing the velocities
    new_velocities = particle_state[1]+(forces/particle_mass)*dt
    new_positions = particle_state[0]+new_velocities*dt
    # The below handles our periodic boundary conditions
    if any(logical_or(new_positions<left_boundary, new_positions>right_boundary)):
        too_low_indices = nonzero(new_positions<left_boundary)[0]
        too_high_indices = nonzero(new_positions>right_boundary)[0]
        for i in range(len(too_low_indices)):
            new_positions[too_low_indices[i]] += domain_length
        for i in range(len(too_high_indices)):
            new_positions[too_high_indices[i]] -= domain_length
    new_particle_state = [new_positions, new_velocities]
    return new_particle_state

def plot_electric_field_energy_history(electric_field_energy_history, t_vec, plot_title='Electric Field Energy History'):
    '''
    Plots the provided electric field energy history
    '''
    plt.figure()
    plt.semilogy(t_vec, electric_field_energy_history)
    plt.title(plot_title)
    plt.xlabel('Time')
    plt.ylabel('Energy')
    plt.show()

def plot_two_stream_instability_growth_rate(electric_field_energy_history, grid, num_particles, t_vec, plot_title='Two Stream Instability'):
    '''
    Plots the two stream instability growth rate against the provided electric field energy history
    '''
    dt = t_vec[1]-t_vec[0]
    plasma_frequency = compute_plasma_frequency(grid, num_particles)
    instability_growth_rate = compute_two_stream_instability_growth_rate(plasma_frequency)
    instability_growth_rate_vec = []
    for index in range(len(electric_field_energy_history)):
        if index == 0:
            instability_growth_rate_vec.append(electric_field_energy_history[index])
        else:
            instability_growth_rate_vec.append(instability_growth_rate_vec[index-1]+dt*instability_growth_rate)
    plt.figure()
    plt.semilogy(t_vec, electric_field_energy_history)
    plt.semilogy(t_vec, instability_growth_rate_vec)
    plt.title(plot_title)
    plt.xlabel('Time')
    plt.ylabel('Energy')
    plt.legend(['Electric Field Energy', 'Theoretical Instability Growth Rate'])
    plt.show()

def plot_energy_histories(electric_field_energy_history, kinetic_energy_history, t_vec, plot_title='Energy Histories'):
    '''
    Plots the electric field energy history, kinetic energy history, and the history of the sum of their energies.
    We ignore that the kinetic_energy_history is reported for times that are one half of a time step behind the electric field energy.
    '''
    plt.figure()
    plt.semilogy(t_vec, electric_field_energy_history)
    plt.semilogy(t_vec, kinetic_energy_history)
    plt.semilogy(t_vec, array(electric_field_energy_history)+array(kinetic_energy_history))
    plt.title(plot_title)
    plt.xlabel('Time')
    plt.ylabel('Energy')
    plt.legend(['Electric Field Energy History', 'Kinetic Field Energy History', 'Total Energy History'])
    plt.show()

def run_simulation(grid, initial_particle_state, t_vec, weighting_order, show_distribution_function=False, show_phase_space_plot=False, show_trajectories=False, simulation_name='1D Plasma Simulation'):
    '''
    Runs a simulation with the given parameters
    '''
    dt = t_vec[1]-t_vec[0]
    electric_field_energy_history = []
    grid_spacing = grid[1]-grid[0]
    kinetic_energy_history = []
    for t in t_vec:
        if t == 0: # Not integrating this step aligns time t with the particle state after the time step
            particle_state = initial_particle_state
            charge_weighted_grid = charge_weighting(grid, particle_state, weighting_order)
            electric_field = field_solve(charge_weighted_grid, grid_spacing)
            electric_field_energy_history.append(compute_electric_field_energy(electric_field, grid_spacing))
            kinetic_energy_history.append(compute_kinetic_energy(particle_state))
        else:
            [particle_state, electric_field] = time_step(dt, grid, grid_spacing, particle_state, weighting_order)
            electric_field_energy_history.append(compute_electric_field_energy(electric_field, grid_spacing))
            kinetic_energy_history.append(compute_kinetic_energy(particle_state))
        if show_phase_space_plot:
            plt.figure('Phase Space Plot')
            plt.scatter(*particle_state)
            plt.xlim(grid[0], grid[-1])
            plt.ylim(vx_domain_endpoints[0], vx_domain_endpoints[1])
            plt.title(simulation_name)
            plt.xlabel('Position')
            plt.ylabel('Velocity')
            plt.show(block=False)
            plt.pause(0.05)
            if t == t_vec[-1]:
                plt.close()
            else:
                plt.clf()
        if show_trajectories:
            plt.figure('Trajectories')
            plt.scatter(*particle_state, c='#1f77b4')
            plt.xlim(grid[0], grid[-1])
            plt.ylim(vx_domain_endpoints[0], vx_domain_endpoints[1])
            plt.title('Particle Trajectories')
            plt.xlabel('Position')
            plt.ylabel('Velocity')
            plt.show(block=False)
            plt.pause(0.05)
            if t == t_vec[-1]:
                plt.close()
        if show_distribution_function:
            plt.figure('Distribution Function')
            plt.hist(particle_state[1], bins=len(grid)//2) # this choice of bin number is arbitrary
            plt.xlabel('Velocity')
            plt.ylabel('Number of Particles')
            plt.title('Particle Distribution Function')
            plt.show(block=False)
            plt.pause(0.05)
            plt.clf()
            if t == t_vec[-1]:
                plt.close()

    return [particle_state, electric_field_energy_history, kinetic_energy_history]

def time_step(dt, grid, grid_spacing, particle_state, weighting_order):
    '''
    Takes a particle state as input and returns the system state advanced in time by dt.
    The velocities in particle_state are assumed to be one half step behind the positions in particle_state.
    The electric field is passed along with the new particle state so it can be used in the energy history diagnostic.
    '''
    charge_weighted_grid = charge_weighting(grid, particle_state, weighting_order)
    electric_field = field_solve(charge_weighted_grid, grid_spacing)
    forces = force_weighting(electric_field, grid, particle_state, weighting_order)
    new_particle_state = particle_push(dt, forces, grid, particle_state)
    return [new_particle_state, electric_field]
            
# Task 1: Generate the Initial Particle State

initial_particle_state = generate_beam_particles(num_beam_particles, x_domain_endpoints)
grid = generate_grid(num_grid_points, x_domain_endpoints)
t_vec = generate_time_vector(dt, simulation_time)

# Task 2: Measuring the Growth Rate

if run_task_2:

    [final_particle_state, electric_field_energy_history, kinetic_energy_history] = run_simulation( 
                                                                                            grid, 
                                                                                            initial_particle_state, 
                                                                                            t_vec, 
                                                                                            weighting_order, 
                                                                                            show_phase_space_plot=show_phase_space_plots, 
                                                                                            simulation_name='Two Stream Instability'
                                                                                            )
    num_particles = len(initial_particle_state[0])
    plot_two_stream_instability_growth_rate(electric_field_energy_history, grid, num_particles, t_vec)

    measured_growth_rate = measure_two_stream_instability_growth_rate(electric_field_energy_history, t_vec)
    plasma_frequency = compute_plasma_frequency(grid, num_particles)
    theoretical_growth_rate = compute_two_stream_instability_growth_rate(plasma_frequency)
    print(f'The measured instability growth rate for task 2 was: {measured_growth_rate}')
    print(f'The predicted growth rate from theory was: {theoretical_growth_rate}')

# Task 3: Measuring Growth Rates for Different Wave Vectors

if run_task_3:

    domain_lengths = [5/2*pi, 9/4*pi, 2*pi, 7/4*pi, 3/2*pi]
    # 4/3*pi is stable so no instability occurs in the simulation time, domains larger than 5/2*pi generate multiple vortices
    measured_instability_growth_rates = []
    theoretical_instability_growth_rates = []

    for domain_length in domain_lengths:

        task_3_x_domain_endpoints = [-domain_length/2, domain_length/2]
        task_3_grid = generate_grid(num_grid_points, task_3_x_domain_endpoints)
        task_3_initial_particle_state = generate_beam_particles(num_beam_particles, task_3_x_domain_endpoints)
        if domain_length == 5/2*pi:
            formatted_domain_length = '$\\frac{5}{2}\pi$'
        elif domain_length == 9/4*pi:
            formatted_domain_length = '$\\frac{9}{4}\pi$'
        elif domain_length == 2*pi:
            formatted_domain_length = '$2\pi$'
        elif domain_length == 7/4*pi:
            formatted_domain_length = '$\\frac{7}{4}\pi$'
        elif domain_length == 3/2*pi:
            formatted_domain_length = '$\\frac{3}{2}\pi$'
        else:
            formatted_domain_length = domain_length

        [final_particle_state, electric_field_energy_history, kinetic_energy_history] = run_simulation( 
                                                                                        task_3_grid, 
                                                                                        task_3_initial_particle_state, 
                                                                                        t_vec, 
                                                                                        weighting_order, 
                                                                                        show_phase_space_plot=show_phase_space_plots, 
                                                                                        simulation_name=f'Two Stream Instability Simulation L={formatted_domain_length}'
                                                                                        )
        num_particles = len(task_3_initial_particle_state[0])
        plot_two_stream_instability_growth_rate(electric_field_energy_history, task_3_grid, num_particles, t_vec, plot_title=f'Two Stream Instability L={formatted_domain_length}')

        measured_growth_rate = measure_two_stream_instability_growth_rate(electric_field_energy_history, t_vec)
        measured_instability_growth_rates.append(measured_growth_rate)

        num_particles = len(initial_particle_state[0])
        plasma_frequency = compute_plasma_frequency(task_3_grid, num_particles)
        theoretical_growth_rate = compute_two_stream_instability_growth_rate(plasma_frequency)
        theoretical_instability_growth_rates.append(theoretical_growth_rate)

    # Plotting the measured vs theoretical growth rates

    kv0s = [2*pi*beam_velocity/domain_length for domain_length in domain_lengths]

    plt.figure()
    plt.scatter(kv0s, measured_instability_growth_rates)
    plt.scatter(kv0s, theoretical_instability_growth_rates)
    plt.xlabel('$kv_0$')
    plt.ylabel('Instability Growth Rate')
    plt.title('Measured and Theoretical Two Stream Instability Growth Rates')
    plt.legend(['Measured Instability Growth Rates', 'Theoretical Instability Growth Rates'])
    plt.show()

# Task 4: Increasing Simulation Resolution

if run_task_4:

    task_4_num_grid_points = 2*num_grid_points
    task_4_grid = generate_grid(task_4_num_grid_points, x_domain_endpoints)

    task_4_num_beam_particles = 2*num_beam_particles
    task_4_initial_particle_state = generate_beam_particles(task_4_num_beam_particles, x_domain_endpoints)

    [final_particle_state, electric_field_energy_history, kinetic_energy_history] = run_simulation( 
                                                                                        task_4_grid, 
                                                                                        task_4_initial_particle_state, 
                                                                                        t_vec, 
                                                                                        weighting_order, 
                                                                                        show_phase_space_plot=show_phase_space_plots, 
                                                                                        simulation_name='Two Stream Instability High Resolution Simulation'
                                                                                        )
    num_particles = len(task_4_initial_particle_state[0])
    plot_two_stream_instability_growth_rate(electric_field_energy_history, task_4_grid, num_particles, t_vec, plot_title='High Resolution Two Stream Instability')

    # Plotting the measured vs theoretical growth rates

    high_resolution_measured_growth_rate = measure_two_stream_instability_growth_rate(electric_field_energy_history, t_vec)
    plasma_frequency = compute_plasma_frequency(task_4_grid, num_particles)
    high_resolution_theoretical_growth_rate = compute_two_stream_instability_growth_rate(plasma_frequency)
    domain_length = task_4_grid[-1]-task_4_grid[0]
    kv0 = 2*pi*beam_velocity/domain_length
    plt.figure()
    if run_task_3: # If task 3 was run, we include the results from that section
        plt.scatter(kv0s, measured_instability_growth_rates)
        plt.scatter(kv0s, theoretical_instability_growth_rates)
        plt.scatter(kv0, high_resolution_measured_growth_rate)
        plt.scatter(kv0, high_resolution_theoretical_growth_rate)
        plt.legend(['Measured Instability Growth Rates', 'Theoretical Instability Growth Rates', 
                    'High Resolution Measured Growth Rate', 'High Resolution Theoretical Growth Rate'])
    else:
        plt.scatter(kv0, high_resolution_measured_growth_rate)
        plt.scatter(kv0, high_resolution_theoretical_growth_rate)
        plt.legend(['High Resolution Measured Growth Rate', 'High Resolution Theoretical Growth Rate'])
    plt.title('Measured vs Theoretical Instability Growth Rates')
    plt.xlabel('$kv_0$')
    plt.ylabel('Instabilty Growth Rate')
    plt.show()

# Task 5: Decreasing Simulation Resolution

if run_task_5:

    task_5_num_grid_points = num_grid_points//2
    task_5_grid = generate_grid(task_5_num_grid_points, x_domain_endpoints)

    task_5_num_beam_particles = num_beam_particles//2
    task_5_initial_particle_state = generate_beam_particles(task_5_num_beam_particles, x_domain_endpoints)

    [final_particle_state, electric_field_energy_history, kinetic_energy_history] = run_simulation( 
                                                                                        task_5_grid, 
                                                                                        task_5_initial_particle_state, 
                                                                                        t_vec, 
                                                                                        weighting_order, 
                                                                                        show_phase_space_plot=show_phase_space_plots, 
                                                                                        simulation_name='Two Stream Instability Low Resolution Simulation'
                                                                                        )
    num_particles = len(task_5_initial_particle_state[0])
    plot_two_stream_instability_growth_rate(electric_field_energy_history, task_5_grid, num_particles, t_vec, plot_title='Low Resolution Two Stream Instability')

    # Custom number of grid points and particles to determine the minimum amount necessary to capture the physical effect

    task_5_num_grid_points = 2
    task_5_grid = generate_grid(task_5_num_grid_points, x_domain_endpoints)
    
    task_5_num_beam_particles = 2
    task_5_initial_particle_state = generate_beam_particles(task_5_num_beam_particles, x_domain_endpoints)

    [final_particle_state, electric_field_energy_history, kinetic_energy_history] = run_simulation( 
                                                                                    task_5_grid, 
                                                                                    task_5_initial_particle_state, 
                                                                                    t_vec, 
                                                                                    weighting_order, 
                                                                                    show_phase_space_plot=show_phase_space_plots, 
                                                                                    simulation_name='Two Stream Instability Custom Low Resolution Simulation'
                                                                                    )
    num_particles = len(task_5_initial_particle_state[0])
    plot_two_stream_instability_growth_rate(electric_field_energy_history, task_5_grid, num_particles, t_vec, plot_title='Custom Low Resolution Two Stream Instability')


# Task 6: Observing Nonlinear Saturation

if run_task_6:

    [final_particle_state, electric_field_energy_history, kinetic_energy_history] = run_simulation( 
                                                                                        grid, 
                                                                                        initial_particle_state, 
                                                                                        t_vec, 
                                                                                        weighting_order, 
                                                                                        show_phase_space_plot=show_phase_space_plots, 
                                                                                        show_trajectories=True,
                                                                                        show_distribution_function=True,
                                                                                        simulation_name='Two Stream Instability Simulation'
                                                                                        )
    # We don't plot the instability growth rate since this simulation is the same as that from task 2